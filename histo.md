# Генерация гистограммы и её визуализация

Терминология:

- **Бин** (англ. bin) – отдельный столбец гистограммы, представляющий сумму (частоту) всех пикселей с одинаковой интенсивностью

Мой вопрос Cloude Sonet 4.5: "_Я занимаюсь анализом изображений на языке Си. Для принятия решений я использую гистограммы. В инструментальных средствах, которые мне доступны есть упоминание о том, что классификация изображений строиться на основании длины проекции гистограммы на ось x. При формировании гистограммы используются параметры lower и upper, которые, возможно, используются как фильтр шумов. Авторы алгоритма построения гистограммы утверждают, что сумма значений lower и upper должна быть равна единице. Однако я знаю, что гистограмма не размещается по центру изображения. Как работает алгоритм построения гистограммы?_"

Судя по вашему описанию, речь идёт о **гистограмме проекций** (projection histogram), которая часто используется в анализе изображений для сегментации, распознавания текста и классификации объектов.

Горизонтальная проекция вычисляется как сумма интенсивностей пикселей в каждой строке изображения.

"Длина проекции на ось x" — это, вероятно, ширина значимой (ненулевой или превышающей порог) части гистограммы.

## Параметры lower и upper

Эти параметры определяют область интереса в гистограмме и работают как весовые коэффициенты для обрезки краёв:

- lower — отсекает нижнюю (левую) часть распределения
- upper — отсекает верхнюю (правую) часть распределения

Условие lower + upper = 1 означает, что они задают процентные доли от полного диапазона

### Механизм работы с несимметричным расположением

Если гистограмма не центрирована, алгоритм, вероятно, работает так:

- Строится гистограмма проекции
- Находится диапазон значимых значений (например, где гистограмма > порога)
- lower определяет, какую долю от начала этого диапазона отсечь
- upper определяет, какую долю от конца отсечь
- "Длина проекции" = оставшийся диапазон после обрезки

Важно: Проверьте документацию вашего инструмента — возможно, lower/upper определяют не отсечки, а **квантили распределения** (например, отбросить 10% самых низких и 10% самых высоких значений), что также объясняет условие суммы = 1.

Эффект параметров:

- lower = 0.0, upper = 1.0 — полная проекция (чувствительна к шуму)
- lower = 0.1, upper = 0.9 — игнорирует 10% краевых пикселей (устойчиво)
- lower = 0.2, upper = 0.8 — сильная фильтрация (может пропустить детали)

**Квантиль распределения** — это значение, ниже которого находится заданный процент наблюдений в наборе данных. Например, медиана — это 0,5‑квантиль, а 0,25‑квантиль называется первым квартилем (_значение, ниже которого 25% данных_). Квантили позволяют описать форму распределения, сравнивать выборки и строить боксплоты.

Квантили фиксируют позиционные характеристики распределения, поэтому их набор сразу показывает, как «распределены» данные вдоль оси значений.

- 0‑квантиль (минимум) - Наименьшее наблюдение - Границы распределения
- 0.25 (первый квартиль) - 25 % наблюдений ≤ значение - Нижняя «плотность»; если Q1 сильно от минимума, хвост слева короток
- 0.5 (медиана)	- 50 % наблюдений ≤ значение - Центр; смещение медианы от среднего указывает на асимметрию
- 0.75 (третий квартиль) - 75 % наблюдений ≤ значение - Верхняя «плотность»; большой разрыв Q3‑Q1 → широкий разброс
- 0.95, 0.99 … - Дальние правые хвосты - Наличие экстремальных значений, «толстый» хвост

>Наиболее часто используемые виды **квантилей**:
>
>Квартили — делят данные на 4 равные части (0.25, 0.5, 0.75)
>Децили — делят данные на 10 равных частей (0.1, 0.2, ..., 0.9)
>Процентили — делят данные на 100 равных частей (0.01, 0.02, ..., 0.99)
>
>В Pandas метод `quantile()` реализует вычисление квантилей как для одномерных (Series), так и для многомерных (DataFrame) данных.

Как квантили формируют представление о форме:

- Симметрия vs. асимметрия – если расстояния от медианы до Q1 и Q3 одинаковы, распределение симметрично; иначе — скошено в сторону более длинного хвоста
- Куртозис (толщина хвостов) – большие разрывы между 0.95‑квантилем и 0.5‑квантилем (или между 0.05 и 0.5) указывают на "толстый" хвост, то есть более высокую вероятность экстремальных значений
- Разброс – интерквартильный размах (Q3‑Q1) измеряет центральный разброс; сравнение его с полным диапазоном (max‑min) показывает, насколько данные сосредоточены в середине
- Множественные моды – если квантили меняются резко (например, большой скачок между соседними процентилями), это может свидетельствовать о наличии нескольких "скоплений" значений
- Таким образом, последовательность квантилей (или их графическое представление в виде боксплота) даёт компактный, но информативный профиль формы распределения без необходимости строить полную гистограмму

### Квантильная интерпретация (наиболее вероятная)

Если lower и upper работают как квантили, то:

```c
// Накопленная сумма гистограммы (CDF)
int total_pixels = 0;
for (int i = 0; i < size; i++) {
    total_pixels += histogram[i];
}

// Найти границы по квантилям
int cumsum = 0;
int left_boundary = 0;
int right_boundary = size - 1;

// Найти left_boundary (где cumsum достигает lower * total)
for (int i = 0; i < size; i++) {
    cumsum += histogram[i];
    if (cumsum >= total_pixels * lower) {
        left_boundary = i;
        break;
    }
}

// Найти right_boundary (где cumsum достигает (1 - upper) * total)
cumsum = 0;
for (int i = 0; i < size; i++) {
    cumsum += histogram[i];
    if (cumsum >= total_pixels * (1.0 - upper)) {
        right_boundary = i;
        break;
    }
}

projection_length = right_boundary - left_boundary;
```

Пример:

- Гистограмма: [0, 0, 5, 10, 20, 15, 8, 3, 0, 0] (индексы 0-9)
- lower = 0.1, upper = 0.9 (отбросить 10% слева, 10% справа)
- Всего пикселей: 61
- Левая граница: где накопилось ≥ 6.1 пикселей → индекс 2-3
- Правая граница: где накопилось ≥ 54.9 пикселей → индекс 7
- Длина проекции = 7 - 3 = 4 (в единицах индексов, умножить на масштаб)

Для вашего случая (несимметричная гистограмма):

- Если пик смещён влево, lower = 0.1 отрежет небольшую часть слева
- upper = 0.9 отрежет большую часть справа
- Результат: проекция будет измерять основную массу объекта, игнорируя шум


## Вариант 2: Пропорциональная обрезка диапазона

Если алгоритм работает с геометрическими границами:

```cpp
// Найти фактические границы сигнала
int first_nonzero = -1, last_nonzero = -1;

for (int i = 0; i < size; i++) {
    if (histogram[i] > threshold) {
        if (first_nonzero == -1) first_nonzero = i;
        last_nonzero = i;
    }
}

// Полный диапазон
int full_range = last_nonzero - first_nonzero;

// Обрезка пропорционально lower/upper
int cut_left = (int)(full_range * lower);
int cut_right = (int)(full_range * upper);

int effective_start = first_nonzero + cut_left;
int effective_end = last_nonzero - cut_right;

projection_length = effective_end - effective_start;
```

Эффект параметров:
lower = 0.0, upper = 1.0 — полная проекция (чувствительна к шуму)
lower = 0.1, upper = 0.9 — игнорирует 10% краевых пикселей (устойчиво)
lower = 0.2, upper = 0.8 — сильная фильтрация (может пропустить детали)

## Подбор параметров

Рекомендуемые значения по типу изображения

- Чёткие края: 0.05 / 0.95 - Малая обрезка
- Зашумлённые: 0.15 / 0.85 - Средняя фильтрация
- С тенями: 0.25 / 0.75 - Агрессивная

## Визуализация в Pandas и matplot

```py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Параметры
width, height = 50, 50
total_pixels = width * height

# Генерация данных
np.random.seed(42)
pixels_bright = np.random.randint(170, 186, int(total_pixels * 0.8))
pixels_very_bright = np.random.randint(230, 246, int(total_pixels * 0.2))
all_pixels = np.concatenate([pixels_bright, pixels_very_bright])
np.random.shuffle(all_pixels)

# Создание DataFrame
df = pd.DataFrame({'pixel_intensity': all_pixels})

# Вычисление границ (10% слева и справа)
lower_percentile = df['pixel_intensity'].quantile(0.10)
upper_percentile = df['pixel_intensity'].quantile(0.90)

print(f"Нижняя граница (10-й перцентиль): {lower_percentile:.2f}")
print(f"Верхняя граница (90-й перцентиль): {upper_percentile:.2f}")

# Фильтрация данных
df['filtered'] = (df['pixel_intensity'] >= lower_percentile) & (df['pixel_intensity'] <= upper_percentile)
df_kept = df[df['filtered']]
df_removed = df[~df['filtered']]

print(f"\nВсего пикселей: {len(df)}")
print(f"Сохранено: {len(df_kept)} ({len(df_kept)/len(df)*100:.1f}%)")
print(f"Отсечено: {len(df_removed)} ({len(df_removed)/len(df)*100:.1f}%)")

# Визуализация 1: Гистограмма с выделением отсечённых данных
plt.figure(figsize=(14, 5))

plt.subplot(1, 2, 1)
bins = np.arange(165, 251, 2)

# Гистограмма сохранённых данных
plt.hist(df_kept['pixel_intensity'], bins=bins, alpha=0.7, color='steelblue', 
         edgecolor='black', label='Сохранённые данные')

# Гистограмма отсечённых данных
plt.hist(df_removed['pixel_intensity'], bins=bins, alpha=0.7, color='red', 
         edgecolor='black', label='Отсечённые данные (10% слева + 10% справа)')

# Границы отсечения
plt.axvline(lower_percentile, color='darkred', linestyle='--', linewidth=2, 
            label=f'Нижняя граница: {lower_percentile:.1f}')
plt.axvline(upper_percentile, color='darkred', linestyle='--', linewidth=2, 
            label=f'Верхняя граница: {upper_percentile:.1f}')

plt.xlabel('Интенсивность пикселей', fontsize=11)
plt.ylabel('Количество пикселей', fontsize=11)
plt.title('Гистограмма с отсечением 10% слева и справа', fontsize=12, fontweight='bold')
plt.legend(fontsize=9)
plt.grid(axis='y', alpha=0.3, linestyle='--')
plt.xlim(165, 250)

# Визуализация 2: Box plot для наглядности
plt.subplot(1, 2, 2)
data_for_box = [df['pixel_intensity'], df_kept['pixel_intensity']]
bp = plt.boxplot(data_for_box, labels=['Все данные', 'После фильтрации'],
                 patch_artist=True, widths=0.6)

# Раскраска box plot
colors = ['lightcoral', 'lightblue']
for patch, color in zip(bp['boxes'], colors):
    patch.set_facecolor(color)

plt.ylabel('Интенсивность пикселей', fontsize=11)
plt.title('Box plot: до и после фильтрации', fontsize=12, fontweight='bold')
plt.grid(axis='y', alpha=0.3, linestyle='--')

plt.tight_layout()
plt.show()

# Визуализация 3: Изображения до и после фильтрации
plt.figure(figsize=(14, 6))

# Исходное изображение
plt.subplot(1, 3, 1)
image_original = all_pixels.reshape(height, width)
plt.imshow(image_original, cmap='gray', vmin=165, vmax=250)
plt.title('Исходное изображение\n(все пиксели)', fontsize=11, fontweight='bold')
plt.colorbar(label='Интенсивность')
plt.axis('off')

# Маска отсечённых пикселей
plt.subplot(1, 3, 2)
mask = df['filtered'].values.reshape(height, width)
image_mask = np.where(mask, image_original, np.nan)

plt.imshow(image_original, cmap='gray', vmin=165, vmax=250, alpha=0.3)
removed_pixels = np.where(~mask, image_original, np.nan)
plt.imshow(removed_pixels, cmap='Reds', vmin=165, vmax=250, alpha=0.8)

plt.title('Отсечённые пиксели\n(выделены красным)', fontsize=11, fontweight='bold')
plt.axis('off')

# Изображение после фильтрации
plt.subplot(1, 3, 3)
image_filtered = np.where(mask, image_original, np.median(df_kept['pixel_intensity']))
plt.imshow(image_filtered, cmap='gray', vmin=165, vmax=250)
plt.title('После фильтрации\n(отсечённые = медиана)', fontsize=11, fontweight='bold')
plt.colorbar(label='Интенсивность')
plt.axis('off')

plt.tight_layout()
plt.show()

# Статистика
print("\n=== Статистика ===")
print("\nДО фильтрации:")
print(df['pixel_intensity'].describe())
print("\nПОСЛЕ фильтрации:")
print(df_kept['pixel_intensity'].describe())
```

## Попытка воспроизвести алгоритм, используемый известным вендором

```py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image

import matplotlib.patches as patches

# Загрузка файла
#from google.colab import files
#uploaded = files.upload()

# Load the BMP as a grayscale (mode 'L')
img = Image.open('image.bmp').convert('L')
arr = np.array(img)          # 2‑D NumPy array of pixel values (0‑255)

# Coordinates
col, row = 112 + 3, 44 + 6
width, height = 5, 7
region = arr[row:row+height, col:col+width]

# ---- Plot whole image ---------------------------------------------
fig, ax = plt.subplots(figsize=(8, 6))
ax.imshow(arr, cmap='gray', origin='upper')
ax.set_title('Grayscale BMP with selected 5×7 area')

# ---- Draw rectangle around the region -----------------------------
rect = patches.Rectangle(
    (col, row),               # (x, y) of the top‑left corner
    width, height,           # width, height in pixels
    linewidth=1,
    edgecolor='red',
    facecolor='none'         # transparent fill
)
ax.add_patch(rect)

plt.axis('off')   # hide axis ticks
plt.show()

# Flatten to 1‑D for the histogram
values = region.ravel()

# Plot histogram
plt.figure(figsize=(6, 4))
plt.hist(values, bins=range(0, 257, 5), edgecolor='black')
plt.title('Histogram of 5×7 region at (112, 44)')
plt.xlabel('Pixel intensity')
plt.ylabel('Frequency')
plt.grid(axis='y', alpha=0.75)
plt.show()
```

Можно добавить фильтрацию с использованием _percentiles_:

```py
# ---- Compute the 10 % and 90 % percentiles -------------------------
p10, p90 = np.percentile(values, [10, 90])

# ---- Keep only values between those percentiles --------------------
filtered = region[(region >= p10) & (region <= p90)]

# Plot histogram
plt.figure(figsize=(6, 4))
plt.hist(values, bins=range(0, 257, 5), edgecolor='red')
plt.hist(filtered, bins=range(0, 257, 5), edgecolor='black')
```

## Попытка определить алгоритм, используя ИИ

Начну обсуждение с ИИ со следующего промпта:

```prompt
Я занимаюсь системой распознавания изображений. Я работаю с изображениями особого типа - на них мало деталей, а изображение контрастное. Например, на светло-сером фоне может быть размещён серый прямоугольник. Мне необходимо понять, есть ли на изображении серый прямоугольник. Я предполагаю, что для этого можно использовать гистограмму. Что именно мне следует делать для решения данной задачи?
```

Cloude Sonnet 4.5 начинает с уже известной мне информации:

Гистограммный анализ хорошо подходит для первичной проверки:

- Постройте гистограмму яркости изображения
- Если на изображении есть прямоугольник на фоне, вы увидите два выраженных пика: один для фона (светло-серый), другой для прямоугольника (серый)
- Если гистограмма показывает только один пик - прямоугольника нет
- Анализируйте соотношение площадей пиков: если второй пик слишком мал или отсутствует, объекта нет

Пороговая сегментация:

- После выявления двух пиков найдите оптимальный порог между ними (метод Оцу отлично подходит)
- Бинаризуйте изображение по этому порогу
- Получите маску потенциального прямоугольника

Морфологический анализ:

- Примените морфологические операции для удаления шума
- Найдите связные компоненты на бинаризованном изображении

Проверка геометрии:

- Для каждой найденной компоненты вычислите ограничивающий прямоугольник
- Проверьте, насколько хорошо компонента заполняет этот прямоугольник (коэффициент заполнения должен быть близок к 1.0 для прямоугольника)
- Дополнительно можно проверить количество углов через детектор углов

Критерии принятия решения:

- Наличие двух пиков на гистограмме
- Коэффициент заполнения > 0.95
- Площадь объекта в разумных пределах

>В реальной задаче может использоваться другая геометрическая фигура - например, равносторонний шестиугольник. По этой причине, проверка геометрии, в моём случае, работать не будет. Хотя идея с коэффициентом заполнения мне очень понравилась.
>
>Следующий вопрос: какие морфологические операции для удаления шума можно использовать?

Открытие (Opening):

- Последовательность: эрозия → дилатация
- Удаляет мелкие светлые объекты и тонкие выступы
- Сглаживает контуры, разрывает узкие перемычки
- Лучше всего подходит для удаления мелких белых шумовых точек на тёмном фоне.

Закрытие (Closing):

- Последовательность: дилатация → эрозия
- Заполняет мелкие тёмные отверстия и разрывы
- Соединяет близко расположенные объекты
- Убирает мелкие чёрные шумовые точки на светлом объекте

Морфологический градиент

- Разность между дилатацией и эрозией
- Выделяет границы объектов

**Дилатация** и **эрозия** - базовые морфологические операции в обработке изображений, которые работают с бинарными (чёрно-белыми) или полутоновыми изображениями.

**Эрозия (Erosion)** 

Принцип работы:

- Структурный элемент (ядро) скользит по изображению
- Пиксель остаётся белым (1) только если все пиксели под ядром белые
- Иначе пиксель становится чёрным (0)

Эффекты:

- Уменьшает размер белых объектов
- Увеличивает размер чёрных областей (отверстий)
- Удаляет тонкие выступы и мелкие светлые детали
- Разрывает тонкие связи между объектами
- "Разъедает" границы объектов

Применение: удаление шума, разделение слипшихся объектов, утончение линий

**Дилатация (Dilation)**

Принцип работы:

- Структурный элемент скользит по изображению
- Пиксель становится белым (1) если хотя бы один пиксель под ядром белый
- Иначе остаётся чёрным (0)

Эффекты:

- Увеличивает размер белых объектов
- Уменьшает или закрывает отверстия
- Заполняет небольшие разрывы и трещины
- Соединяет близкие объекты
- "Наращивает" границы объектов

Применение: заполнение дыр, соединение разорванных линий, увеличение объектов

Важные свойства:

- Эрозия и дилатация не обратимы друг другу (не отменяют друг друга)
- Обе операции зависят от формы и размера структурного элемента
- Они являются двойственными операциями: эрозия объекта = дилатация фона

>**Дилатация** и **эрозия** - очень интересные техники, но в моём случае крайне сложно выполнить бинаризацию, поскольку заранее неизвестно, какая именно яркость будет у фона и прямоугольника.
>
>Следующий промпт: "в моём случае крайне сложно выполнить бинаризацию, поскольку заранее неизвестно, какая именно яркость будет у фона и прямоугольника. Какой алгоритм работы с гистограммой можно использовать в данном случае?"

**Метод Оцу (Otsu's method)** — НАИЛУЧШИЙ ВЫБОР:

Принцип: автоматически находит оптимальный порог, максимизирующий межкластерную дисперсию (разделяет гистограмму на два класса с максимальным различием).

Преимущества:

- Полностью автоматический
- Отлично работает для бимодальных гистограмм (два пика: фон + объект)
- Не требует знания цветов заранее
- Оптимален для вашей задачи с прямоугольником на фоне

Применение: если гистограмма имеет два выраженных пика, метод Оцу идеально разделит фон и прямоугольник.

**Адаптивная бинаризация**:

Принцип: порог вычисляется локально для каждой области изображения.

Варианты:

- Среднее значение в окрестности минус константа
- Взвешенное среднее (Гауссовское)
- Когда использовать: если освещение неравномерное или есть градиенты.

**Анализ долин гистограммы** (Valley emphasis):

Принцип: ищет минимум между двумя пиками гистограммы.

Алгоритм:

- Сгладить гистограмму
- Найти два максимума (пика)
- Найти минимум между ними — это и есть порог

Преимущество: интуитивно понятен для случая с двумя цветами.

**Метод треугольника** (Triangle method):

Принцип: строит линию от максимального пика гистограммы до конца диапазона, находит точку максимального расстояния от этой линии до гистограммы.

Когда использовать: если один из объектов (фон или прямоугольник) занимает значительно большую площадь.

>После серии уточнений, Claude даёт следующую информацию:

**Метод процентилей** (_Percentile-based thresholding_) с анализом пиков.

Алгоритм работает следующим образом:

Шаг 1: Фильтрация по процентилям

- Отсекаются крайние значения гистограммы (по умолчанию 0-20% и 80-100%)
- Остаётся "рабочий диапазон" (20%-80%)
- Это исключает выбросы, шумы, артефакты и крайние значения яркости

Шаг 2: Анализ пиков в отфильтрованном диапазоне

- В оставшемся диапазоне ищутся два пика
- Анализируется длина проекции (ширина) каждого пика
- Порог определяется на основе этих проекций

Зачем нужна адаптация процентилей?

- 20%-80%: стандартный случай с умеренным контрастом
- 10%-90%: когда объект занимает больше площади или контраст выше
- 5%-95%: изображения с широким динамическим диапазоном или когда важные детали близки к краям гистограммы

Похожие методы:

- Triangle method (метод треугольника) - но он не использует процентили
- Minimum Error Thresholding - моделирует два класса, но без явной фильтрации
- Robust Automatic Threshold Selection (RATS) - использует процентили для устойчивости

Ваш метод наиболее близок к **адаптивной версии метода Otsu с предварительной фильтрацией по процентилям**, где вместо всей гистограммы анализируется только её "значимая" часть.

>А какие именно ,бины отсекаются на гистограмме. Отсекаются ли бины с минимальной, или максимальной яркостью, или удаляются бины с низкой частотой?

Вариант 1: **Отсечение по интенсивности** (positional percentiles)

Удаляются бины по их позиции на оси X (интенсивности):

- 20%-80%: удаляются 20% самых тёмных пикселей и 20% самых светлых
- Например, для 8-бит (0-255): могут отсекаться бины 0-50 и 200-255
- Не зависит от высоты бинов, только от количества пикселей

Пример: Если у вас черный фон (пик на 0) и белый объект (пик на 255), то отсекаются именно эти крайние интенсивности, даже если пики там огромные.

Вариант 2: **Отсечение по высоте бинов** (frequency-based)

Удаляются бины с низкой частотой (высотой):

- Сортируются все бины по количеству пикселей в них
- Отсекаются 20% бинов с наименьшим количеством пикселей
- Позиция на оси X не важна

Пример: Если есть шум - редкие пиксели разбросаны по всей гистограмме, то удалятся именно эти "низкие" бины, независимо от их яркости.

>Мой случай - не биомедицина. Я должен распознать метку в инфракрасном диапазоне на купюре.

В вашем случае скорее всего Вариант 1 - отсечение по процентилям интенсивности

Почему:

Типичная картина ИК-изображения купюры:

- Фон купюры - относительно однородный, средне-серый
- ИК-метка - яркое пятно (если метка отражает ИК) или тёмное (если поглощает)
- Края, тени, артефакты - очень тёмные или очень светлые пиксели

Отсечение 20%-80% удаляет:

- Самые тёмные 20% - глубокие тени, края, дефекты сканирования
- Самые светлые 20% - засветки, блики, шум

Результат: остаётся средний диапазон, где контраст между фоном и меткой максимален.

>В моей системе используется только один набор порогов для фильтрации, однако существует два типа проблем: тени/засветки и шум с малой частотой бина. Если предположить, что анализируется не вся купюра, а только некоторый участок. Можно ли понять, какой вариант фильтрации предпочтителен?

Если участок = область вокруг предполагаемой метки:

Вариант 1 (процентильная фильтрация) — предпочтителен

Почему:

- На локальном участке вероятны тени от краёв метки, засветки от её центра
- Эти артефакты попадут в хвосты распределения (самые тёмные/светлые 20%)
- Шум с малой частотой бина будет распределён по всему диапазону, его доля на краях не критична
- Процентильная фильтрация гарантированно удалит экстремумы, независимо от их природы

Если участок = однородный фон или калибровочная область:

Вариант 2 (фильтрация редких бинов) — предпочтителен

Почему:

- Однородный фон должен давать узкое распределение (один-два пика)
- Тени/засветки здесь маловероятны
- Шум проявится как редкие выбросы в разных бинах (солевой шум, битые пиксели)
- Отсечение бинов с малой частотой точно удалит именно шум, сохранив основной сигнал
